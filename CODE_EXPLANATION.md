# Star Cluster Kinematic Classification - Code Explanation

This document explains the Python scripts used in this project to classify star clusters based on their kinematic properties using machine learning.

## Overall Goal

The primary objective is to leverage kinematic data (stellar motions) from the Gaia DR3 dataset to train a machine learning model capable of distinguishing between Open Clusters and Globular Clusters. This aligns with the STEAM IC 2025 Astronomy prompt [cite: 18] aiming to improve star cluster classification methods[cite: 20].

## Scripts Overview

The workflow is divided into two main scripts:

1.  **`1_data_acquisition.py`**: Handles fetching and initial cleaning of data.
2.  **`2_ml_classification.py`**: Performs feature engineering and trains/evaluates the classification model.

---

### `1_data_acquisition.py`

**Purpose:**
This script queries the Gaia DR3 database to retrieve data for individual stars within specified regions around known open and globular clusters. It then applies basic filters based on parallax (distance), proper motion (movement across the sky), and data quality flags to select likely members of each cluster.

**Functionality:**

1.  **Cluster Definition:** A dictionary (`cluster_params`) stores the target clusters' names, celestial coordinates (RA, Dec), search radius, and expected ranges for parallax and proper motion.
2.  **Gaia Query:** For each cluster, it constructs and executes an ADQL query using `astroquery.gaia` to fetch relevant stellar data (`source_id`, position, parallax, proper motions, radial velocity, magnitudes, `ruwe`). Broad kinematic filters are applied within the query to reduce download size.
3.  **Data Cleaning:** The retrieved data undergoes filtering:
    * **Parallax Filter:** Selects stars within the cluster's specific parallax range and requires a parallax signal-to-noise ratio > 5.
    * **Proper Motion Filter:** Selects stars within the cluster's specific proper motion range (pmRA and pmDec).
    * **RUWE Filter:** Removes stars with poor astrometric solutions (`ruwe >= 1.4`).
4.  **Output:** The script combines the cleaned data (likely members) from all processed clusters into a single `astropy` Table. This table, containing columns like `ra`, `dec`, `parallax`, `pmra`, `pmdec`, `radial_velocity`, `cluster_name`, `cluster_type`, etc., is saved to a FITS file named `cleaned_cluster_members.fits`.

**Dependencies:** `numpy`, `astropy`, `astroquery`

---

### `2_ml_classification.py`

**Purpose:**
This script takes the cleaned star member data generated by the first script, calculates cluster-level kinematic features, trains a Random Forest machine learning model to classify clusters as 'Open' or 'Globular', and evaluates the model's performance.

**Functionality:**

1.  **Load Data:** Reads the `cleaned_cluster_members.fits` file into memory (using `astropy.table.Table` and converting to `pandas.DataFrame`).
2.  **Feature Engineering (`calculate_cluster_features` function):**
    * Groups the star data by `cluster_name`.
    * For each cluster (if it has sufficient members, e.g., >= 5):
        * Calculates the *mean* parallax, proper motions, and radial velocity.
        * Calculates the *standard deviation* of proper motions and radial velocity. These standard deviations represent the internal **velocity dispersion** of the cluster.
        * Converts proper motion dispersions into physical velocity units (km/s) using the cluster's mean distance (derived from mean parallax).
        * Calculates a combined 3D velocity dispersion (`dispersion_3d_kms`).
        * If mean parallax and mean radial velocity are available, it uses the `gala` library to calculate **orbital parameters** (total orbital energy `E` and angular momentum `Lz`) within a standard Milky Way gravitational potential model. (Eccentricity calculation is omitted for simplicity but could be added).
    * Outputs a `pandas` DataFrame where each row represents one cluster and columns represent the engineered features (`dispersion_3d_kms`, `orbital_energy`, `orbital_Lz`, component dispersions, etc.) and the `cluster_type` label.
    * Handles missing values (`NaN`) in the engineered features by filling them with the median value for that feature.
3.  **Machine Learning:**
    * Selects the relevant kinematic features (X) and the target labels (y: 0 for Open, 1 for Globular).
    * Splits the cluster feature data into training (70%) and testing (30%) sets using `sklearn.model_selection.train_test_split`. Stratification ensures similar class proportions in both sets.
    * Initializes and trains a `sklearn.ensemble.RandomForestClassifier`.
4.  **Evaluation:**
    * Predicts cluster types for the test set.
    * Calculates and prints accuracy, a detailed classification report (precision, recall, F1-score), and a confusion matrix.
    * Calculates and displays the importance of each feature used by the model.
    * Saves plots for the confusion matrix (`confusion_matrix.png`) and feature importance (`feature_importance.png`).

**Dependencies:** `numpy`, `pandas`, `astropy`, `gala-astro`, `scikit-learn`, `matplotlib`, `seaborn`